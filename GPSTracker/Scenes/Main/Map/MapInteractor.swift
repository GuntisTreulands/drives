//
//  MapInteractor.swift
//  GPS Tracker
//
//  Created by Guntis on 2022.
//  Copyright (c) 2022 . All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreData

protocol MapBusinessLogic {
	func fetchPoints(request: Map.FetchPoints.Request)
	func deleteAPoint(request: Map.DeleteAPoint.Request)
    func moveAPoint(request: Map.MoveAPoint.Request)
}

protocol MapDataStore {
	var identificator: String { get set }
	var monthIdentificator: String { get set }
}

class MapInteractor: NSObject, MapBusinessLogic, MapDataStore, NSFetchedResultsControllerDelegate {
	
	var presenter: MapPresentationLogic?
	var fetchedResultsController: NSFetchedResultsController<DriveEntity>!

  	var identificator: String = ""
  	var monthIdentificator: String = ""
	var mapDrive: DriveEntity?

	// MARK: MainListBusinessLogic

	func fetchPoints(request: Map.FetchPoints.Request) {
		if fetchedResultsController == nil {
			let context = DataBaseManager.shared.mainManagedObjectContext()
			let fetchRequest: NSFetchRequest<DriveEntity> = DriveEntity.fetchRequest()
			let sortByMonth = NSSortDescriptor(key: "monthString", ascending: true)
			let sortByStartTime = NSSortDescriptor(key: "startTime", ascending: false)
			fetchRequest.sortDescriptors = [sortByMonth, sortByStartTime]

			if identificator.isEmpty == false {
				fetchRequest.predicate = NSPredicate(format:"identificator == %@", identificator)
				fetchRequest.fetchLimit = 1
			} else if monthIdentificator.isEmpty == false {
				fetchRequest.predicate = NSPredicate(format:"sectionedMonthString == %@", monthIdentificator)
			}
			
			fetchedResultsController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: context, sectionNameKeyPath: nil, cacheName: nil)

			fetchedResultsController.delegate = self
		}


		var drive: DriveEntity?
		var drives: [DriveEntity]?

		do {
			try fetchedResultsController.performFetch()



			if let firstDrive = fetchedResultsController.fetchedObjects?.first {
				drive = firstDrive
				mapDrive = drive

				drives = fetchedResultsController.fetchedObjects
			}

		} catch let error {
			// Something went wrong
			print("Something went wrong. \(error)")
		}

		var sortedPointsPerDrive: [[PointEntity]] = []

		var totalCount = 0

		if let drives = drives {
			for aDrive in drives {
				if drives.count == 1 {
					let sortedPoints: [PointEntity] = aDrive.rPoints?.sortedArray(using: [NSSortDescriptor(key: "timestamp", ascending: true)]) as! [PointEntity]
					sortedPointsPerDrive.append(sortedPoints)
				} else {
					let sortedPoints: [PointEntity] = aDrive.rFilteredPoints?.sortedArray(using: [NSSortDescriptor(key: "timestamp", ascending: true)]) as! [PointEntity]
					totalCount += sortedPoints.count
					sortedPointsPerDrive.append(sortedPoints)
				}
			}
		}

		print("totalCount \(totalCount)"); //484757  //134586  //99942  //62079

    	let response = Map.FetchPoints.Response(fetchedPoints: sortedPointsPerDrive, monthIdentificator: monthIdentificator)
    	presenter?.presentData(response: response)

	}

	func deleteAPoint(request: Map.DeleteAPoint.Request)
	{
		let task =
		{
			let context = DataBaseManager.shared.mainManagedObjectContext()
			let point = context.object(with: request.point.objectID)

			context.delete(point)
			DataBaseManager.shared.saveContext()

			if let mapDrive = self.mapDrive {
				let drive: DriveEntity = context.object(with: mapDrive.objectID) as! DriveEntity
				drive.totalTime = 0
				drive.totalDistance = 0
				drive.startAddress = ""
				drive.endAddress = ""

				if let filteredPointsSet = drive.rFilteredPoints {
					for point in filteredPointsSet.allObjects as! [PointEntity] {
						point.rFilteredDrive = nil
					}
				}

				drive.rFilteredPoints = nil
				
				DataBaseManager.shared.saveContext()
				DataBaseWorker.calculateDistanceAndTimeForDrives()
				DataBaseWorker.calculateFilteredPointsForDrives()
				self.fetchPoints(request: Map.FetchPoints.Request.init())
			}
		}

		DataBaseManager.shared.addATask(action: task)
	}
    
    
    func moveAPoint(request: Map.MoveAPoint.Request)
    {
        let task =
        {
            let context = DataBaseManager.shared.mainManagedObjectContext()
            let point: PointEntity = context.object(with: request.point.objectID) as! PointEntity
            
            point.latitude = request.newCoordinate.latitude
            point.longitude = request.newCoordinate.longitude
            
            DataBaseManager.shared.saveContext()

            if let mapDrive = self.mapDrive {
                let drive: DriveEntity = context.object(with: mapDrive.objectID) as! DriveEntity
                drive.totalTime = 0
                drive.totalDistance = 0
                drive.startAddress = ""
                drive.endAddress = ""

                if let filteredPointsSet = drive.rFilteredPoints {
                    for point in filteredPointsSet.allObjects as! [PointEntity] {
                        point.rFilteredDrive = nil
                    }
                }

                drive.rFilteredPoints = nil
                
                DataBaseManager.shared.saveContext()
                DataBaseWorker.calculateDistanceAndTimeForDrives()
                DataBaseWorker.calculateFilteredPointsForDrives()
                self.fetchPoints(request: Map.FetchPoints.Request.init())
            }
        }

        DataBaseManager.shared.addATask(action: task)
    }

	// MARK: NSFetchedResultsControllerDelegate
	
  	func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
		fetchPoints(request: Map.FetchPoints.Request())
	}
}
